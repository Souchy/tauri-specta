/* eslint-disable */
// This file was generated by [tauri-specta](https://github.com/specta-rs/tauri-specta). Do not edit this file manually.

/** user-defined commands **/

export namespace commands {
	/**
	 * HELLO
	 * WORLD
	 * !!!!
	 */
	export async function helloWorld(myName: string) : Promise<string> {
	    return await TAURI_INVOKE("hello_world", { myName });
	}
	export async function goodbyeWorld() : Promise<string> {
	    return await TAURI_INVOKE("goodbye_world");
	}
	export async function hasError() : Promise<Result<string, number>> {
	    try {
	        return { status: "ok", data: await TAURI_INVOKE("has_error") };
	    } catch (e) {
	        if(e instanceof Error) throw e;
	        else return { status: "error", error: e  as any };
	    }
	}
	export async function generic() : Promise<void> {
	    await TAURI_INVOKE("generic");
	}
	/**
	 * @deprecated This is a deprecated function
	 */
	export async function deprecated() : Promise<void> {
	    await TAURI_INVOKE("deprecated");
	}
	export async function typesafeErrorsUsingThiserror() : Promise<Result<null, MyError>> {
	    try {
	        return { status: "ok", data: await TAURI_INVOKE("typesafe_errors_using_thiserror") };
	    } catch (e) {
	        if(e instanceof Error) throw e;
	        else return { status: "error", error: e  as any };
	    }
	}
	export async function typesafeErrorsUsingThiserrorWithValue() : Promise<Result<null, MyError2>> {
	    try {
	        return { status: "ok", data: await TAURI_INVOKE("typesafe_errors_using_thiserror_with_value") };
	    } catch (e) {
	        if(e instanceof Error) throw e;
	        else return { status: "error", error: e  as any };
	    }
	}
	export namespace library_service {
		export async function getLibrary() : Promise<void> {
		    await TAURI_INVOKE("get_library");
		}
		export async function helloApp() : Promise<Result<string, string>> {
		    try {
		        return { status: "ok", data: await TAURI_INVOKE("hello_app") };
		    } catch (e) {
		        if(e instanceof Error) throw e;
		        else return { status: "error", error: e  as any };
		    }
		}
		/**
		 * Execute a command against the database
		 */
		export async function addDb(db: string) : Promise<Result<string, string>> {
		    try {
		        return { status: "ok", data: await TAURI_INVOKE("add_db", { db }) };
		    } catch (e) {
		        if(e instanceof Error) throw e;
		        else return { status: "error", error: e  as any };
		    }
		}
		/**
		 * Execute a command against the database
		 */
		export async function getDb(db: string) : Promise<Result<string, string>> {
		    try {
		        return { status: "ok", data: await TAURI_INVOKE("get_db", { db }) };
		    } catch (e) {
		        if(e instanceof Error) throw e;
		        else return { status: "error", error: e  as any };
		    }
		}
	}
	
	export namespace library_service {
		export class BlueStruct {
			private constructor(private readonly structId: string) {}
			/**
			 * `constructor` or `new`
			 * Actually should be static method that returns an instance and make the ctor private, so call it instance.
			 * 
			 * We can either pass the BlueStruct instance around, or use a State to store instances.
			 * If we use multiple instances in State, we need a way to identify/key them.
			 * Dont really want to mix both, because that's 2 sources of truth for the struct's data.
			 * Issue with passing instance, is doing stuff here in rust doesnt affect the instance in TS.
			 * So State it is.
			 * Some classes may be singletons, other will have keys.
			 * The constructor can return the key when needed.
			 * And generate getters/setters for the other fields.
			 */
			static async instance(someField: string) : Promise<BlueStruct> {
			    return new BlueStruct(await TAURI_INVOKE("instance", { someField }));
			}
			/**
			 * Now we can ignore State and Id parameters in the TS function.
			 * The class will hold the Id and pass it to the .invoke().
			 */
			async getField() : Promise<Result<string, string>> {
			    try {
			        return { status: "ok", data: await TAURI_INVOKE("get_field", { structId: this.structId }) };
			    } catch (e) {
			        if(e instanceof Error) throw e;
			        else return { status: "error", error: e  as any };
			    }
			}
			async setField(value: string) : Promise<Result<string, string>> {
			    try {
			        return { status: "ok", data: await TAURI_INVOKE("set_field", { structId: this.structId, value }) };
			    } catch (e) {
			        if(e instanceof Error) throw e;
			        else return { status: "error", error: e  as any };
			    }
			}
		}
	}
	
	export namespace nested {
		export async function someStruct() : Promise<MyStruct> {
		    return await TAURI_INVOKE("some_struct");
		}
	}
	
}

/** user-defined events **/

export const events = __makeEvents__<{
	emptyEvent: EmptyEvent,
	myDemoEvent: DemoEvent
}>({
	emptyEvent: "empty-event",
	myDemoEvent: "myDemoEvent"
})

/** user-defined constants **/

export const universalConstant = 42 as const;

/** user-defined types **/

export type Custom = string
export type DemoEvent = string
export type EmptyEvent = null
export type Id = string
export type MyError = { type: "IoError" } | { type: "AnotherError"; data: string }
export type MyError2 = { type: "IoError"; data: string }
export type MyStruct = { some_field: string }

/** tauri-specta globals **/

import {
  invoke as TAURI_INVOKE,
  Channel as TAURI_CHANNEL,
} from "@tauri-apps/api/core";
import * as TAURI_API_EVENT from "@tauri-apps/api/event";
import { type Webview as __Webview__ } from "@tauri-apps/api/webview";
import { type Window as __Window__ } from "@tauri-apps/api/window";

type __EventObj__<T> = {
  listen: (
    cb: TAURI_API_EVENT.EventCallback<T>,
  ) => ReturnType<typeof TAURI_API_EVENT.listen<T>>;
  once: (
    cb: TAURI_API_EVENT.EventCallback<T>,
  ) => ReturnType<typeof TAURI_API_EVENT.once<T>>;
  emit: null extends T
  ? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
  : (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>;
};

export type Result<T, E> =
  | { status: "ok"; data: T }
  | { status: "error"; error: E };

export function __makeEvents__<T extends Record<string, any>>(
  mappings: Record<keyof T, string>,
) {
  const result = {} as {
    [K in keyof T]: __EventObj__<T[K]> & {
      (window: __Webview__ | __Window__): __EventObj__<T[K]>;
    };
  };

  for (const key in mappings) {
    const name = mappings[key];

    const base: __EventObj__<any> = {
      listen: (cb) => TAURI_API_EVENT.listen(name, cb),
      once: (cb) => TAURI_API_EVENT.once(name, cb),
      emit: (payload: any) => TAURI_API_EVENT.emit(name, payload),
    };

    const withWindow = (window: __Webview__ | __Window__): __EventObj__<any> => ({
      listen: (cb) => window.listen(name, cb),
      once: (cb) => window.once(name, cb),
      emit: (payload: any) => window.emit(name, payload),
    });

    result[key] = Object.assign(withWindow, base);
  }

  return result;
}

